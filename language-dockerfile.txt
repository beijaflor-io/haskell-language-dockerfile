-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Dockerfile linter, parser, pretty-printer and embedded DSL
--   
--   Forked from <tt>hadolint</tt>.
--   
--   All functions for parsing, printing and writting Dockerfiles are
--   exported through <tt>Language.Dockerfile</tt>. For more fine-grained
--   operations look for specific modules that implement a certain
--   functionality.
--   
--   There are two flags in this package, which enable building two
--   executables:
--   
--   <ul>
--   <li><tt>hadolint</tt> Enables building the <tt>hadolint</tt>
--   executable, though you might prefer to use the hadolint package
--   directly</li>
--   <li><tt>dockerfmt</tt> Builds example pretty-printer usage, which
--   reads a Dockerfile and pretty-prints it to stdout</li>
--   </ul>
--   
--   See the <a>GitHub project</a> for the source-code and examples.
@package language-dockerfile
@version 0.3.4.0

module Language.Dockerfile.Bash
shellcheck :: String -> [Comment]

module Language.Dockerfile.Normalize

-- | Remove new line escapes and join escaped lines together on one line to
--   simplify parsing later on. Escapes are replaced with line breaks to
--   not alter the line numbers.
normalizeEscapedLines :: String -> String

module Language.Dockerfile.Lexer
lexer :: TokenParser ()
reserved :: String -> Parser ()
reservedOp :: String -> Parser ()
natural :: Parser Integer
commaSep :: ParsecT String () Identity a -> ParsecT String () Identity [a]
stringLiteral :: ParsecT String () Identity String
brackets :: ParsecT String () Identity a -> ParsecT String () Identity a
identifier :: ParsecT String () Identity String
lexeme :: ParsecT String () Identity a -> ParsecT String () Identity a

module Language.Dockerfile.Syntax
type Image = String
type Tag = String
data Ports
Ports :: [Integer] -> Ports
PortStr :: String -> Ports
type Directory = String
data BaseImage
UntaggedImage :: Image -> BaseImage
TaggedImage :: Image -> Tag -> BaseImage
DigestedImage :: Image -> ByteString -> BaseImage

-- | Type of the Dockerfile AST
type Dockerfile = [InstructionPos]
type Source = String
type Destination = String
type Arguments = [String]
type Pairs = [(String, String)]

-- | All commands available in Dockerfiles
data Instruction
From :: BaseImage -> Instruction
Add :: Source -> Destination -> Instruction
User :: String -> Instruction
Label :: Pairs -> Instruction
Stopsignal :: String -> Instruction
Copy :: Source -> Destination -> Instruction
Run :: Arguments -> Instruction
Cmd :: Arguments -> Instruction
Workdir :: Directory -> Instruction
Expose :: Ports -> Instruction
Volume :: String -> Instruction
Entrypoint :: Arguments -> Instruction
Maintainer :: String -> Instruction
Env :: Pairs -> Instruction
Arg :: String -> Instruction
Comment :: String -> Instruction
OnBuild :: Instruction -> Instruction
EOL :: Instruction
type Filename = String
type Linenumber = Int

-- | <a>Instruction</a> with additional location information required for
--   creating good check messages
data InstructionPos
InstructionPos :: Instruction -> Filename -> Linenumber -> InstructionPos
instruction :: InstructionPos -> Instruction
sourcename :: InstructionPos -> Filename
instance GHC.Show.Show Language.Dockerfile.Syntax.InstructionPos
instance GHC.Classes.Ord Language.Dockerfile.Syntax.InstructionPos
instance GHC.Classes.Eq Language.Dockerfile.Syntax.InstructionPos
instance GHC.Show.Show Language.Dockerfile.Syntax.Instruction
instance GHC.Classes.Ord Language.Dockerfile.Syntax.Instruction
instance GHC.Classes.Eq Language.Dockerfile.Syntax.Instruction
instance GHC.Show.Show Language.Dockerfile.Syntax.BaseImage
instance GHC.Classes.Ord Language.Dockerfile.Syntax.BaseImage
instance GHC.Classes.Eq Language.Dockerfile.Syntax.BaseImage
instance GHC.Classes.Ord Language.Dockerfile.Syntax.Ports
instance GHC.Classes.Eq Language.Dockerfile.Syntax.Ports
instance GHC.Show.Show Language.Dockerfile.Syntax.Ports
instance Data.String.IsString Language.Dockerfile.Syntax.Ports

module Language.Dockerfile.Rules
data Metadata
Metadata :: String -> Severity -> String -> Metadata
[code] :: Metadata -> String
[severity] :: Metadata -> Severity
[message] :: Metadata -> String
data Check
Check :: Metadata -> Filename -> Linenumber -> Bool -> Check
[metadata] :: Check -> Metadata
[filename] :: Check -> Filename
[linenumber] :: Check -> Linenumber
[success] :: Check -> Bool
link :: Metadata -> String
type Rule = Dockerfile -> [Check]
mapInstructions :: Metadata -> (Instruction -> Bool) -> Rule
instructionRule :: String -> Severity -> String -> (Instruction -> Bool) -> Rule
dockerfileRule :: String -> Severity -> String -> ([Instruction] -> Bool) -> Rule
analyze :: [Rule] -> Dockerfile -> [Check]
rules :: [Rule]
commentMetadata :: Comment -> Metadata
shellcheckBash :: Dockerfile -> [Check]
bashCommands :: [String] -> [[String]]
absoluteWorkdir :: Rule
hasMaintainer :: Rule
usingProgram :: String -> [String] -> Bool
multipleCmds :: Rule
multipleEntrypoints :: Rule
wgetOrCurl :: Rule
invalidCmd :: Rule
noRootUser :: Rule
noCd :: Rule
noSudo :: Rule
noUpgrade :: Rule
noUntagged :: Rule
noLatestTag :: Rule
aptGetVersionPinned :: Rule
aptGetPackages :: [String] -> [String]
aptGetCleanup :: Rule
useAdd :: Rule
invalidPort :: Rule
maintainerAddress :: Rule
pipVersionPinned :: Rule
isAptGetInstall :: [[Char]] -> Bool
aptGetYes :: Rule
aptGetNoRecommends :: Rule
isArchive :: String -> Bool
isUrl :: String -> Bool
copyInsteadAdd :: Rule
instance GHC.Classes.Eq Language.Dockerfile.Rules.Check
instance GHC.Classes.Eq Language.Dockerfile.Rules.Metadata
instance GHC.Classes.Ord Language.Dockerfile.Rules.Check

module Language.Dockerfile.FormatCheck
formatCheck :: Check -> String

module Language.Dockerfile.Syntax.Lift
instance Language.Haskell.TH.Syntax.Lift Language.Dockerfile.Syntax.InstructionPos
instance Language.Haskell.TH.Syntax.Lift Language.Dockerfile.Syntax.Instruction
instance Language.Haskell.TH.Syntax.Lift Language.Dockerfile.Syntax.BaseImage
instance Language.Haskell.TH.Syntax.Lift Language.Dockerfile.Syntax.Ports

module Language.Dockerfile.Parser
comment :: Parser Instruction
taggedImage :: Parser BaseImage
digestedImage :: Parser BaseImage
untaggedImage :: Parser BaseImage
baseImage :: Parser BaseImage
from :: Parser Instruction
cmd :: Parser Instruction
copy :: Parser Instruction
stopsignal :: Parser Instruction
quotedValue :: Parser String
rawValue :: Parser String
singleValue :: Parser String
pair :: Parser (String, String)
pairs :: Parser Pairs
remainingPairs :: Parser Pairs
label :: Parser Instruction
arg :: Parser Instruction
env :: Parser Instruction
user :: Parser Instruction
add :: Parser Instruction
expose :: Parser Instruction
run :: Parser Instruction
untilEol :: Parser String
untilOccurrence :: String -> Parser String
workdir :: Parser Instruction
volume :: Parser Instruction
maintainer :: Parser Instruction
argumentsExec :: Parser Arguments
argumentsShell :: Parser Arguments
arguments :: Parser Arguments
entrypoint :: Parser Instruction
onbuild :: Parser Instruction
eolInstruction :: Parser Instruction
parseInstruction :: Parser Instruction
contents :: Parser a -> Parser a
eol :: Parser ()
dockerfile :: Parser Dockerfile
parseString :: String -> Either ParseError Dockerfile
parseFile :: String -> IO (Either ParseError Dockerfile)

module Language.Dockerfile.PrettyPrint

-- | Pretty print a <a>Dockerfile</a> to a <a>String</a>
prettyPrint :: Dockerfile -> String

-- | Pretty print a <a>InstructionPos</a> to a <a>String</a>
prettyPrintInstructionPos :: InstructionPos -> String
prettyPrintBaseImage :: BaseImage -> Doc
prettyPrintPairs :: Pairs -> Doc
prettyPrintPair :: (String, String) -> Doc
prettyPrintArguments :: Arguments -> Doc
prettyPrintInstruction :: Instruction -> Doc

module Language.Dockerfile.EDSL.Types
data EBaseImage
EUntaggedImage :: String -> EBaseImage
ETaggedImage :: String -> String -> EBaseImage
EDigestedImage :: String -> ByteString -> EBaseImage
data EInstruction next
From :: EBaseImage -> next -> EInstruction next
Add :: Source -> Destination -> next -> EInstruction next
User :: String -> next -> EInstruction next
Label :: Pairs -> next -> EInstruction next
StopSignal :: String -> next -> EInstruction next
Copy :: Source -> Destination -> next -> EInstruction next
RunArgs :: Arguments -> next -> EInstruction next
CmdArgs :: Arguments -> next -> EInstruction next
Workdir :: Directory -> next -> EInstruction next
Expose :: Ports -> next -> EInstruction next
Volume :: String -> next -> EInstruction next
EntrypointArgs :: Arguments -> next -> EInstruction next
Maintainer :: String -> next -> EInstruction next
Env :: Pairs -> next -> EInstruction next
Arg :: String -> next -> EInstruction next
Comment :: String -> next -> EInstruction next
OnBuildRaw :: Instruction -> next -> EInstruction next
Embed :: [InstructionPos] -> next -> EInstruction next
instance GHC.Base.Functor Language.Dockerfile.EDSL.Types.EInstruction
instance GHC.Classes.Ord Language.Dockerfile.EDSL.Types.EBaseImage
instance GHC.Classes.Eq Language.Dockerfile.EDSL.Types.EBaseImage
instance GHC.Show.Show Language.Dockerfile.EDSL.Types.EBaseImage
instance Data.String.IsString Language.Dockerfile.EDSL.Types.EBaseImage

module Language.Dockerfile.EDSL

-- | The type of <tt>Identity</tt> based EDSL blocks
type EDockerfileM = Free EInstruction

-- | The type of free monad EDSL blocks
type EDockerfileTM = FreeT EInstruction
type EInstructionM = Free EInstruction
type EInstructionTM = FreeT EInstruction
embed :: MonadFree EInstruction m_aTFe => [InstructionPos] -> m_aTFe ()
onBuildRaw :: MonadFree EInstruction m_aTFb => Instruction -> m_aTFb ()
comment :: MonadFree EInstruction m_aTF8 => String -> m_aTF8 ()
arg :: MonadFree EInstruction m_aTF5 => String -> m_aTF5 ()
env :: MonadFree EInstruction m_aTF2 => Pairs -> m_aTF2 ()
maintainer :: MonadFree EInstruction m_aTEZ => String -> m_aTEZ ()
entrypointArgs :: MonadFree EInstruction m_aTEW => Arguments -> m_aTEW ()
volume :: MonadFree EInstruction m_aTET => String -> m_aTET ()
expose :: MonadFree EInstruction m_aTEQ => Ports -> m_aTEQ ()
workdir :: MonadFree EInstruction m_aTEN => Directory -> m_aTEN ()
cmdArgs :: MonadFree EInstruction m_aTEK => Arguments -> m_aTEK ()
runArgs :: MonadFree EInstruction m_aTEH => Arguments -> m_aTEH ()
copy :: MonadFree EInstruction m_aTED => Source -> Destination -> m_aTED ()
stopSignal :: MonadFree EInstruction m_aTEA => String -> m_aTEA ()
label :: MonadFree EInstruction m_aTEx => Pairs -> m_aTEx ()
user :: MonadFree EInstruction m_aTEu => String -> m_aTEu ()
add :: MonadFree EInstruction m_aTEq => Source -> Destination -> m_aTEq ()
from :: MonadFree EInstruction m_aTCP => EBaseImage -> m_aTCP ()
runDockerWriter :: (MonadWriter [Instruction] m) => EDockerfileM a -> m a
runDockerWriterIO :: (Monad m, MonadTrans t, Monad (t m), MonadWriter [Instruction] (t m), MonadIO (t m)) => EDockerfileTM m a -> t m a
runDef :: MonadWriter [t] m => (t1 -> t) -> t1 -> m b -> m b
runDef2 :: MonadWriter [t] m => (t1 -> t2 -> t) -> t1 -> t2 -> m b -> m b
runD :: MonadWriter [Instruction] m => EInstruction (m b) -> m b
instructionPos :: Instruction -> InstructionPos

-- | Runs the Dockerfile EDSL and returns a <tt>Dockerfile</tt> you can
--   pretty print or manipulate
toDockerfile :: EDockerfileM a -> Dockerfile

-- | runs the Dockerfile EDSL and returns a <a>String</a> using
--   <a>PrettyPrint</a>
--   
--   <pre>
--   import           Language.Dockerfile
--   
--   main :: IO ()
--   main = writeFile "something.dockerfile" $ toDockerfileStr $ do
--       from (tagged "fpco/stack-build" "lts-6.9")
--       add "." "<i>app</i>language-dockerfile"
--       workdir "<i>app</i>language-dockerfile"
--       run (words "stack build --test --only-dependencies")
--       cmd (words "stack test")
--   </pre>
toDockerfileStr :: EDockerfileM a -> String
untagged :: String -> EBaseImage
tagged :: String -> String -> EBaseImage
digested :: String -> ByteString -> EBaseImage
ports :: [Integer] -> Ports
port :: Integer -> Ports
run :: MonadFree EInstruction m => String -> m ()
entrypoint :: MonadFree EInstruction m => String -> m ()
cmd :: MonadFree EInstruction m => String -> m ()

-- | ONBUILD Dockerfile instruction
--   
--   Each nested instruction gets emitted as a separate <tt>ONBUILD</tt>
--   block
--   
--   <pre>
--   <a>toDockerfile</a> $ do
--       from "node"
--       run "apt-get update"
--       onBuild $ do
--           run "echo more-stuff"
--           run "echo here"
--   </pre>
onBuild :: MonadFree EInstruction m => EDockerfileM a -> m ()

-- | A version of <a>toDockerfile</a> which allows IO actions
toDockerfileIO :: MonadIO m => EDockerfileTM m t -> m Dockerfile

-- | A version of <a>toDockerfileStr</a> which allows IO actions
toDockerfileStrIO :: MonadIO m => EDockerfileTM m t -> m String

-- | Just runs the EDSL's writer monad
runDockerfileIO :: MonadIO m => EDockerfileTM m t -> m (t, Dockerfile)

-- | Runs the EDSL's writer monad and pretty-prints the result
runDockerfileStrIO :: MonadIO m => EDockerfileTM m t -> m (t, String)

module Language.Dockerfile.EDSL.Quasi

-- | Quasiquoter for embedding dockerfiles on the EDSL
--   
--   <pre>
--   putStr $ <a>toDockerfile</a> $ do
--       from "node"
--       run "apt-get update"
--       [edockerfile|
--       RUN apt-get update
--       CMD node something.js
--       |]
--   </pre>
edockerfile :: QuasiQuoter
edockerfileE :: String -> ExpQ
dockerfile :: QuasiQuoter
dockerfileE :: String -> ExpQ
filterEOL :: [InstructionPos] -> [InstructionPos]

module Language.Dockerfile

-- | Type of the Dockerfile AST
type Dockerfile = [InstructionPos]
parseString :: String -> Either ParseError Dockerfile
parseFile :: String -> IO (Either ParseError Dockerfile)

-- | Pretty print a <a>Dockerfile</a> to a <a>String</a>
prettyPrint :: Dockerfile -> String

-- | Pretty print a <a>InstructionPos</a> to a <a>String</a>
prettyPrintInstructionPos :: InstructionPos -> String

-- | runs the Dockerfile EDSL and returns a <a>String</a> using
--   <a>PrettyPrint</a>
--   
--   <pre>
--   import           Language.Dockerfile
--   
--   main :: IO ()
--   main = writeFile "something.dockerfile" $ toDockerfileStr $ do
--       from (tagged "fpco/stack-build" "lts-6.9")
--       add "." "<i>app</i>language-dockerfile"
--       workdir "<i>app</i>language-dockerfile"
--       run (words "stack build --test --only-dependencies")
--       cmd (words "stack test")
--   </pre>
toDockerfileStr :: EDockerfileM a -> String

-- | Runs the Dockerfile EDSL and returns a <tt>Dockerfile</tt> you can
--   pretty print or manipulate
toDockerfile :: EDockerfileM a -> Dockerfile

-- | A version of <a>toDockerfileStr</a> which allows IO actions
toDockerfileStrIO :: MonadIO m => EDockerfileTM m t -> m String

-- | A version of <a>toDockerfile</a> which allows IO actions
toDockerfileIO :: MonadIO m => EDockerfileTM m t -> m Dockerfile

-- | Just runs the EDSL's writer monad
runDockerfileIO :: MonadIO m => EDockerfileTM m t -> m (t, Dockerfile)

-- | Runs the EDSL's writer monad and pretty-prints the result
runDockerfileStrIO :: MonadIO m => EDockerfileTM m t -> m (t, String)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a
from :: MonadFree EInstruction m_aTCP => EBaseImage -> m_aTCP ()
tagged :: String -> String -> EBaseImage
untagged :: String -> EBaseImage
digested :: String -> ByteString -> EBaseImage
add :: MonadFree EInstruction m_aTEq => Source -> Destination -> m_aTEq ()
user :: MonadFree EInstruction m_aTEu => String -> m_aTEu ()
label :: MonadFree EInstruction m_aTEx => Pairs -> m_aTEx ()
stopSignal :: MonadFree EInstruction m_aTEA => String -> m_aTEA ()
copy :: MonadFree EInstruction m_aTED => Source -> Destination -> m_aTED ()
run :: MonadFree EInstruction m => String -> m ()
runArgs :: MonadFree EInstruction m_aTEH => Arguments -> m_aTEH ()
cmd :: MonadFree EInstruction m => String -> m ()
cmdArgs :: MonadFree EInstruction m_aTEK => Arguments -> m_aTEK ()
workdir :: MonadFree EInstruction m_aTEN => Directory -> m_aTEN ()
expose :: MonadFree EInstruction m_aTEQ => Ports -> m_aTEQ ()
ports :: [Integer] -> Ports
port :: Integer -> Ports
volume :: MonadFree EInstruction m_aTET => String -> m_aTET ()
entrypoint :: MonadFree EInstruction m => String -> m ()
entrypointArgs :: MonadFree EInstruction m_aTEW => Arguments -> m_aTEW ()
maintainer :: MonadFree EInstruction m_aTEZ => String -> m_aTEZ ()
env :: MonadFree EInstruction m_aTF2 => Pairs -> m_aTF2 ()
arg :: MonadFree EInstruction m_aTF5 => String -> m_aTF5 ()
comment :: MonadFree EInstruction m_aTF8 => String -> m_aTF8 ()

-- | ONBUILD Dockerfile instruction
--   
--   Each nested instruction gets emitted as a separate <tt>ONBUILD</tt>
--   block
--   
--   <pre>
--   <a>toDockerfile</a> $ do
--       from "node"
--       run "apt-get update"
--       onBuild $ do
--           run "echo more-stuff"
--           run "echo here"
--   </pre>
onBuild :: MonadFree EInstruction m => EDockerfileM a -> m ()
onBuildRaw :: MonadFree EInstruction m_aTFb => Instruction -> m_aTFb ()
embed :: MonadFree EInstruction m_aTFe => [InstructionPos] -> m_aTFe ()

-- | Quasiquoter for embedding dockerfiles on the EDSL
--   
--   <pre>
--   putStr $ <a>toDockerfile</a> $ do
--       from "node"
--       run "apt-get update"
--       [edockerfile|
--       RUN apt-get update
--       CMD node something.js
--       |]
--   </pre>
edockerfile :: QuasiQuoter

-- | The type of <tt>Identity</tt> based EDSL blocks
type EDockerfileM = Free EInstruction

-- | The type of free monad EDSL blocks
type EDockerfileTM = FreeT EInstruction
data EBaseImage
EUntaggedImage :: String -> EBaseImage
ETaggedImage :: String -> String -> EBaseImage
EDigestedImage :: String -> ByteString -> EBaseImage
dockerfile :: QuasiQuoter

-- | All commands available in Dockerfiles
data Instruction
From :: BaseImage -> Instruction
Add :: Source -> Destination -> Instruction
User :: String -> Instruction
Label :: Pairs -> Instruction
Stopsignal :: String -> Instruction
Copy :: Source -> Destination -> Instruction
Run :: Arguments -> Instruction
Cmd :: Arguments -> Instruction
Workdir :: Directory -> Instruction
Expose :: Ports -> Instruction
Volume :: String -> Instruction
Entrypoint :: Arguments -> Instruction
Maintainer :: String -> Instruction
Env :: Pairs -> Instruction
Arg :: String -> Instruction
Comment :: String -> Instruction
OnBuild :: Instruction -> Instruction
EOL :: Instruction

-- | <a>Instruction</a> with additional location information required for
--   creating good check messages
data InstructionPos
InstructionPos :: Instruction -> Filename -> Linenumber -> InstructionPos
data BaseImage
UntaggedImage :: Image -> BaseImage
TaggedImage :: Image -> Tag -> BaseImage
DigestedImage :: Image -> ByteString -> BaseImage
type Image = String
type Tag = String
data Ports
type Directory = String
type Source = String
type Destination = String
type Arguments = [String]
type Pairs = [(String, String)]
type Filename = String
type Linenumber = Int

-- | The abstract data type <tt>ParseError</tt> represents parse errors. It
--   provides the source position (<a>SourcePos</a>) of the error and a
--   list of error messages (<a>Message</a>). A <tt>ParseError</tt> can be
--   returned by the function <a>parse</a>. <tt>ParseError</tt> is an
--   instance of the <a>Show</a> and <a>Eq</a> classes.
data ParseError :: *
instruction :: InstructionPos -> Instruction
instructionPos :: Instruction -> InstructionPos
sourcename :: InstructionPos -> Filename
